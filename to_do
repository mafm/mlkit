                             VERSION 3


ERROR:
SYMPTOM:
TESTFILE:
PRIORITY: (HIGH|MEDIUM|LOW)
REPORTED BY: (MT|ME|FAXE) + date
TO BE FIXED BY: (MT|ME|FAXE)

=============================== BUGS ===============================


=============================== WAIT ===============================

So as to make printing of profile graphs use less ink, modify rp2ps
such that black is not used as the color for the largest area in
a profile graph.

Large elaboration bases are annotated on the ast (functor bindings)
during elaboration. Such annotated bases cause opacity elimination to
be slow when compiling large programs; opacity elimination applies
realisations to ast annotated objects. To improve speed of
compilation, we should restrict the annotated bases to those
identifiers that occur free in the functor binding. Is it possible to
do this restriction during the pass for finding free identifiers
(FreeIds)?

In Fig 8.1 the regions r17 and r19 appear never to be used (because we
do not print the at r17 and at r19 that hold the empty region
parameter records. This might confuse users (and it makes the program
less pretty). I think we should clean up the implementation to get rid
of this problem. (One could of course hack the pretty-printer, but it
would be more satisfactory to get the letregions deleted properly - or
at least marked by "omit"). -Mads.
 
Implement some kind of project reuse; it currently takes too long for
the manager to find out that the code for the basis library can be
reused. The problem is that the result basis for the basis library
project is reconstructed, from the result bases for the individual
sources of the library, every time the project is reused.

Variables that occur free in a program unit are associated with
labelled slots in the data segment of the final executable; thus,
these variables need not be stored in closures. It suffices to fetch
them from the data segment.

Make recompilation dependent on a notion of `compiler configuration'
(list of entry-flag pairs); in this way, we can ensure that linking
will always succeed even if the compiler configuration changes. A
configuration should include entries such as ("tag_values", BOOL
false), and so on.

Currently, we do not treat multiple declarations of the same functor
identifier in the same project. We can allow this; but we cannot allow
a functor identifier to be declared more than once in a source file.

Allow ``inlining'' of functors. Syntax:
     bdy ::= inline funidseq                     functor inlining
          |  local bdy in bdy end                local
	  |  bdy bdy |  _                        sequential
          |  file.sml | file.sig | file.fun      source file
          |  file.o                              precompiled object
          |  file.grm                            yacc source file
          |  file.lex                            lex source file

Declare polymorphic eq. in the initial basis, and make it impossible
to redeclare equality; if equality is in the initial basis then
in-lining happens automatically.

Get TestEnv performance test to work properly under HPUX 10. The
problem is that the UNIX program `top' generates unparsable output
under HPUX 10. Are there any system calls that can do the same job as
`top'?

How are we going to model the differences between the specification of
the Math structure and the semantics of /usr/include/math.h? For now,
I think that we should just do whatever math.h does; MosML does not
implement NaN, posInf, and negInf; instead, MosML raises Overflow when
the specification suggests to return NaN, posInf, or negInf.

Implementation of Real.round on systems that do not have rint() (i.e.,
systems based on gcc's library). Real.round is broken in MosML, so we
cannot copy the code.

Why are regions that are passed to primitive functions in the runtime
system not tested for resetting automatically (in CompLamb);
currently, the user must do the resetting in the C function. Is there
a reason? What about Mogensens idea about resetting?

============================= DONE ================================

ERROR:
SYMPTOM:
TESTFILE: (file in TestEnv, added to acceptance test)
PRIORITY: (HIGH|MEDIUM|LOW)
REPORTED BY: (MT|ME|FAXE) + date
TO BE FIXED BY: (MT|ME|FAXE)
FIXED BY: (MT|ME|FAXE) + date

-------------------------------------------------------------------

[(ME 1998-08-21): Eliminate generated object code that is never used
by applying a backward use-analysis. We cannot eliminate object code
for units with side-effects, however.]

-------------------------------------------------------------------

[(ME 1998-08-21): Delete the TestEnv/Output_X_on_Y directories and
replace them by one directory expected_output. The output from running
the tests should be the same on different machines. Moreover, the
output should be the same even if profiling is enabled (profiling
messages should be directed to stdErr).]

-------------------------------------------------------------------

[(ME 1998-09-26): Remove the problematic value space (valspace). It
seems that kam variables are local to each target unit; currently,
however, we allocate a global store (in data space) for these
variables and this store grows, infinitely, when the project is
recompiled. Instead, we can associate spilled registers to local slots
in each compilation unit.]

-------------------------------------------------------------------

ERROR: reelaboration of functor fails for overloading
SYMPTOM: 
	  Impossible: StatObject.instance'.fresh
	  Error while reconstructing functor body for Util
	  *** CRASH raised *

TESTFILE: ~mael/kit_projects/modules/util.sml
PRIORITY: HIGH
REPORTED BY: ME 1998-10-08
TO BE FIXED BY: ME
FIXED BY: ME and MT
COMMENT: realisations were not meant to be applied to type schemes for
overloaded functions. However, Elsmans implementation of opacity
elimination applies realisations to a bases annotated in the ast
during elaboration.

-------------------------------------------------------------------

ERROR: basis restriction crashes compilation
SYMPTOM: 
  [compiling body of functor F (from project interp.pm) begin]
  problems with tyname environment
  tyname: t
  is not in the domain of the environment:
  ...
TESTFILE: ~mael/kit_projects/modules/interp.pm
PRIORITY: HIGH
REPORTED BY: ME 1998-10-12
TO BE FIXED BY: ME
FIXED BY: ME 1998-10-12
COMMENT: When restricting an interpretation basis, then associations
for tynames that occur free in the restricted interpretation functor
environment must be kept (ManagerObjects.IntBasis.restr).

-------------------------------------------------------------------

ERROR: bdy truncation
SYMPTOM: compilation crashes because .bdy file for 
functor is truncated:

                   structure F : sig end

TESTFILE: ~mael/kit_projects/modules/bdy_truncate.sml
PRIORITY: HIGH
REPORTED BY: ME 1998-10-12
TO BE FIXED BY: ME
FIXED BY: ME 1998-10-12
COMMENT: The position info annotated on the body of functor
bindings were wrong! I inserted a LETstrexp around the
body, so that the info on sigexp constraints did not have
to be altered (which would make error-reporting disastrous).

-------------------------------------------------------------------

ERROR: pattern match incorrect redundancy
SYMPTOM: The Kit reports that the second rule of the program

  fun f {a=1, b} = 1
    | f {b=1, a} = 2
    | f _ = 3

is redundant and generates incorrect code for the function.

TESTFILE: ~mael/kit_projects/modules/patterns.sml
PRIORITY: HIGH
REPORTED BY: ME 1998-10-13
TO BE FIXED BY: ME
FIXED BY: ME 1998-10-21
COMMENT: There was a problem with the ordering of record elements in 
patterns (file CompileDec.sml).

--------------------------------------------------------------------

[(ME 1998-10-21): Allow ``local'' source files in projects.  DONE]

--------------------------------------------------------------------
