(* Global flags *)

(*$Flags: FLAGS CRASH*)

functor Flags(structure Crash: CRASH): FLAGS =
  struct
    fun die s = Crash.impossible ("Flags." ^ s)

     (* To introduce a new dynamic flag, do the following:

            Use the function add_flag_to_menu from within a module.

        OR

        (a) declare a new boolean reference, r
        (b) add r to the menu (with a menu text) at an appropriate place
        (c) add r to the `Adding initial entries' section below, together with 
	    a search key (a string), which can be used by the modules that 
            want to access the flag.
        (d) recompile this functor and the functor which uses the new flag

     *)

    val warnings: string list ref = ref [];
    (* Warnings are collected during compilation and printed all at once
       at the end of the compilation of a program. The printing is done
       in Interpreter, which also resets the reference *)

    (* Pretty Printing *)

    val raggedRight = ref true

    (* Debugging Flags *)
    val DEBUG_LEXING       = ref false
    val DEBUG_PARSING      = ref false
    val DEBUG_ELABDEC      = ref false
    val DEBUG_ELABTOPDEC   = ref false
    val DEBUG_ENVIRONMENTS = ref false
    val DEBUG_ERRORPRINT   = ref false
    val DEBUG_EVALDEC      = ref false
    val DEBUG_EVALTOPDEC   = ref false
    val DEBUG_FLEXRECORDS  = ref false
    val DEBUG_STATOBJECTS  = ref false
    val DEBUG_TYPES        = ref false
    val DEBUG_TYVARS       = ref false

   (*Compiler debug options: *)
    val DEBUG_COMPILER          = ref false
    val DEBUG_DECISIONTREE      = ref false
    val DEBUG_MATCHCOMPILER     = ref false
    val DEBUG_OPTIMISER         = ref false

    val optimiser               = ref true
    val type_check_lambda       = ref true
          (*don't change 29/03/1997 17:35. tho.*)

    (* Elimination of polymorphic equality *)
    val eliminate_polymorphic_equality = ref true

    val unbox_datatypes         = ref false
    val tag_integers            = ref false
    val tag_values              = ref false

   (* Region inference debug options *)

    val DEBUG_REGIONINFERENCE =  ref false
    val print_effects = ref false
    val print_regions = ref false
    val print_types  = ref false
    val warn_on_escaping_rhos = ref false
    val all_multiplicities_infinite = ref false   
    (* attop/atbot inference *)

    val statistics_after_optimisation = ref false
    val print_attop_atbot_expression = ref false
    val print_drop_regions_expression = ref false
    val print_call_explicit_expression = ref false
    val print_physical_size_inference_expression = ref false

    val disable_atbot_analysis = ref false
    val print_K_normal_forms = ref false
    val debug_which_at = ref false
    val enhanced_atbot_analysis = ref false

    (* Flags for region profiling. *)
    val region_profiling        = ref false
    val gen_lambda_with_pp      = ref false
    val gen_vcg_graph           = ref false
    val print_all_program_points = ref true
    val program_points = (ref []): int list ref
    val region_paths = (ref[]): (int*int) list ref

    val chat                    = ref true

    val source_directory  = ref "You_did_not_set_source_directory"
    val target_directory = ref "You_did_not_set_target_directory"
    val log_directory = ref "You_did_not_set_log_directory"
    val log_to_file = ref true ;
    val link_filename       = ref "link"
    val target_file_extension = ref ".s" (*or ".c", with the C back end*)

    (*The following four have to do with the compilation of the C or the
     HP PA-RISC code generated by the kit.  (The kit will compile
     your ml program all the way to an executable by using a
     C compiler.)  These ref's are used in Manager/Manager.sml.*)

    val path_to_runtime = ref "You_did_not_set_path_to_runtime"
    val path_to_runtime_prof = ref "You_did_not_set_path_to_runtime_prof"
    val c_compiler = ref "cc -Aa" (*or maybe "gcc -ansi"*)
    val c_libs = ref "-lm" (*include math lib when compiling target code from the kit*)

    val path_to_kit_script = ref "You_did_not_set_path_to_kit_script"
           (*used in this module and in TestEnv*)
      
    (*the following five are only used by TestEnv:*)
    val kit_version = ref "You_did_not_set_kit_version" (*e.g. "ML_to_HPPA_on_HPUX"*)
    val kit_source_directory = ref "You_did_not_set_kit_source_directory"
          (*path to source of this compiler.  For instance,
	   Common/Flags.sml is in kit_source_directory*)
    val path_to_consult_file = ref "You_did_not_set_path_to_consult_file"
    val test_env_directory = ref "You_did_not_set_kit_source_directory"
    val kit_architecture = ref "You_did_not_set_kit_architecture"

    val colwidth               = ref 80

    val log        = ref std_out

    val indent_ccode   = ref false;

    (* Program manager *)

    fun dummy _ : unit = output (std_out,
				 "uninitialised function reference in Flags")
    val project_file_name = ref "dummy"
    val build_project_ref: (unit -> unit)ref = ref dummy
    val show_project_ref: (unit -> unit)ref  = ref dummy
    val read_project_ref: (string -> unit)ref  = ref dummy
    val comp_ref: (string -> unit)ref  = ref dummy
    val test_ref: (unit -> unit)ref  = ref dummy
    val current_source_file = ref "dummy"

    (* Garbage Collection *)
           
    val garbage_collection = ref true

          (*************************************************)
          (*           structure ParseScript               *)
          (*                                               *)
          (* Parsing settings (filenames and directories)  *)
          (* from a script file                            *)
          (*************************************************)

structure ParseScript: sig 
			 datatype const = INT of int | STRING of string | BOOL of bool
			 exception ParseScript of string
			 val parseScript : string -> (string * const) list 
		       end =

  (* syntax: 

     DEC::= val ID : TYPE  = CONST REST 
     REST::= ;
         |  DEC
     ID  ::= sequence_of_letters_underbars_and_primes
     TYPE::= int | string | bool
     CONST::= ml_integer_constant | ml_string_constant | ml_bool_constant
  
     blanks, tabs and newlines are separators;
     comments are enclosed in (* and *) and can be nested.
  *)

struct
  datatype ty = Int | String | Bool
  datatype const = INT of int | STRING of string | BOOL of bool
  type parse_result = (string * const) list
  type state  = string list * parse_result 
  type parser = state -> state
  exception ParseScript of string
  
  fun is_letter_or_digit (ch: string) = 
    ord ch >= ord "a" andalso ord ch <= ord "z" orelse
    ord ch >= ord "A" andalso ord ch <= ord "Z" orelse
    ch = "'" orelse ch = "_"
  
  fun is_space (ch: string) =
      ch = " " orelse ch = "\t" orelse ch = "\n"
  
  fun lex_id (input: string list) : string * string list =
    let val (id_l , rest) = List.removePrefix is_letter_or_digit input
    in (implode id_l, rest)
    end
  
  fun skip_colon (":" :: rest) = rest
    | skip_colon _ = raise ParseScript "expected ':' "
  
  fun skip_val ("v" :: "a" :: "l" :: rest) = rest
    | skip_val _ = raise ParseScript "expected 'val' "
  
  fun skip_eq ("=" ::rest ) = rest
    | skip_eq _ = raise ParseScript "expteced '=' "
  
  fun drop_spaces (l: string list) = List.dropPrefix is_space l 
  
  fun lex_const ty input =
    case ty of 
      Int => (case IntParse.parse (implode input) of
                OK (i, rest) => (INT i , explode rest)
              | _ => raise ParseScript "expected integer constant"
             )
    | String => (case StringParse.parse (implode input) of
		   OK (s, rest) => (STRING s  , explode rest)
		 | _ => raise ParseScript "expected string constant"
		)
    | Bool => (case BoolParse.parse (implode input) of
		 OK (b, rest) => (BOOL b , explode rest)
	       | _ => raise ParseScript "expected bool constant"
	      )
  
  fun lex_type ("i" :: "n" :: "t" ::rest) = (Int, rest)
    | lex_type ("s" :: "t" :: "r" :: "i" :: "n" :: "g" :: rest) = (String, rest)
    | lex_type ("b" :: "o" :: "o" :: "l" :: rest) = (Bool, rest)
    | lex_type _ = raise ParseScript "expected 'int', 'string' or 'bool'";
  
  fun parseDec (input: string list, acc_bind: parse_result) : state  =
      parseRest
        let val input1 =  (drop_spaces o skip_val o  drop_spaces) input
            val (id,input2) = lex_id input1
            val input3 = (drop_spaces o skip_colon o drop_spaces) input2
            val (ty, input4) = lex_type input3
            val input5 = (drop_spaces o skip_eq o drop_spaces) input4
            val (c, input6) = lex_const ty input5
        in            
            (input6, (id, c)::acc_bind)
        end 
  and parseRest (input: string list, acc_bind: parse_result) : state =
        let val input1 = drop_spaces input
        in  case input1 of
             ";" :: input2 => (input2, rev acc_bind)
            |"v" :: _ => parseDec(input1, acc_bind)
            | _ => raise ParseScript "expected 'val' or ';'"
        end;
  
  fun drop_comments (l: string list) : string list =
    let fun loop(n, "(" :: "*" :: rest ) = loop(n+1, rest)
          | loop(n, "*" :: ")" :: rest ) = loop(n-1, if n=1 then " "::rest else rest)
          | loop(0, ch ::rest) = ch :: loop (0,rest) (* martin; was `ch :: rest'... *)
          | loop(0, []) = []
          | loop(n, ch ::rest) = loop(n,rest)
          | loop(n, []) = raise ParseScript "unclosed comment"
    in
        loop(0,l)
    end;
  
  fun parseScript(filename: string) = 
    (let val state as (_, bindings) = 
         parseDec(drop_comments(explode(StringParse.fromFile filename)),[])
     in bindings
     end handle Io s => raise ParseScript s)
       handle ParseScript s => (output(!log, "\n *parse error*: " ^ s ^ "\n");
				raise ParseScript s)

end (* ParseScript *)


           
          (**************************************************)
          (*           structure Directory                  *)
          (*                                                *)
          (* Directory, holding associations for            *)
	  (* various settings and operations for toggling,  *)
	  (* etc. Also, readScript is here.                 *)
          (**************************************************)

structure Directory : sig
                        type state
			val get_state           : unit -> state
			val reset_state         : state -> unit
			val is_on               : string -> bool 
			val turn_on             : string -> unit
			val turn_off            : string -> unit
			val lookup_flag_entry   : string -> bool ref
			val add_string_entry    : string * string ref -> unit
			val get_string_entry    : string -> string
			val lookup_string_entry : string -> string ref
			val add_int_entry       : string * int ref -> unit
			val add_bool_entry      : string * bool ref -> unit
			val readScript          : unit -> unit
			val readScriptName      : string -> unit
			val show_script_entries : unit -> unit
		      end =
struct

  (* Directory for dynamic flags. *)  
  type directory = {strings: (string*string ref) list ref,
                    integers: (string*int ref) list ref,
		    booleans: (string*bool ref) list ref};
  val dir = {strings = ref [], integers = ref [], booleans = ref []} : directory

  (* Make it possible to get and set a state. *)
  type state = {strings:  (string*string ref) list,
		integers: (int*int ref) list,
		booleans: (bool*bool ref) list}

  fun get_state () : state =
    {strings  = List.map (fn (_,str_ref)  => (!str_ref, str_ref))  (!(#strings dir)),
     integers = List.map (fn (_,int_ref)  => (!int_ref, int_ref))  (!(#integers dir)),
     booleans = List.map (fn (_,bool_ref) => (!bool_ref, bool_ref)) (!(#booleans dir))}

  fun reset_state ({strings, integers, booleans} : state) =
    let
      fun update (x, x_ref) = x_ref := x
    in
      (List.apply update strings;
       List.apply update integers;
       List.apply update booleans)
    end

  (* Toggles and check for boolean flags. *)

  fun lookup_flag_entry key =
        (#2 o List.first (fn (key':string,_) => key=key') o ! o #booleans) dir
	handle List.First _ => die ("lookup_flag_entry " ^ key)
  val is_on = ! o lookup_flag_entry
  fun turn_on (key: string) : unit = lookup_flag_entry key := true
  fun turn_off (key: string) : unit = lookup_flag_entry key := false

  (* Functions for adding an entry to the directory. *)
  local
    fun add_entry([], key, r) = [(key,r)]
      | add_entry((key',r')::rest,key,r) = if key=key' then (key,r)::rest
					   else (key',r')::add_entry(rest, key, r) 
  in
    fun add_string_entry(key,r) = #strings dir := add_entry(!(#strings dir),key,r)
    fun add_int_entry(key,r) = #integers dir := add_entry(!(#integers dir),key,r)
    fun add_bool_entry(key,r) = #booleans dir := add_entry(!(#booleans dir),key,r)
  end

  (* Functions for retrieving a string value. *)
  fun lookup_string_entry key =
        (#2 o List.first (fn (key' : string, _) => key=key') o ! o #strings) dir
	    handle List.First _ => die ("lookup_string_entry " ^ key)
  val get_string_entry = ! o lookup_string_entry

  (* Read and interpret script and update directory according to 
   * parse result. *)
  local
    fun update_assoc([], key,_) = output(std_out, "Cannot find script key: " ^ key ^ "\n")
      | update_assoc((key',r)::rest, key, value) = 
      if key=key' then r:= value else update_assoc(rest, key, value);

    fun update_string(key, value) = update_assoc(!(#strings dir), key, value);
    fun update_int(key, value) = update_assoc(!(#integers dir), key, value);
    fun update_bool(key, value) = update_assoc(!(#booleans dir), key, value);

    fun interpret (l:(string*ParseScript.const) list) : unit = 
      List.apply (fn (s, ParseScript.STRING newval) => update_string(s,newval)
                   | (s, ParseScript.INT newval) => update_int(s,newval)
                   | (s, ParseScript.BOOL newval) => update_bool(s,newval)) l;
  in
    fun readScript (): unit = 
          interpret (ParseScript.parseScript (!path_to_kit_script))
    fun readScriptName name : unit = 
          interpret (ParseScript.parseScript (name))
  end

  (* Write all possible entries which can be changed from *)
  (* the script file.                                     *)
  fun show_script_entries () =
    let
      fun out(s) = output(std_out, s)
      fun outLine (s) = out(s ^ "\n")
	
      val dirEntriesName = (List.map #1 (!(#strings (dir)))) @ 
	                   (List.map #1 (!(#integers (dir)))) @ 
			   (List.map #1 (!(#booleans (dir))))

      val dirEntriesValue = (List.map (! o #2) (!(#strings (dir)))) @ 
                            (List.map (Int.string o ! o #2) (!(#integers (dir)))) @ 
			    (List.map (Bool.string o ! o #2) (!(#booleans (dir))))
      
      fun calc_width w [] = w
	| calc_width w (s::xs) = 
	    if w < (String.size s) then
	      calc_width (String.size s) xs
	    else
	      calc_width w xs

      val column_width = calc_width 0 (dirEntriesName @ dirEntriesValue)

      fun make_field s = String.padR " " column_width s
      
      val horizontal_column_line = String.padR "-" column_width ""
      fun horizontal_line 0 res = res ^ "+"
	| horizontal_line n res = horizontal_line (n-1) (res ^ "+" ^ horizontal_column_line)
      
      fun make_row [] s = s ^ "|"
	| make_row (x::xs) s = make_row xs (s ^ "|" ^ (make_field x))
      
    in
      (outLine (horizontal_line 2 "");
       outLine (make_row ["Name to use in script file", "Value of variable now"] "");
       outLine (horizontal_line 2 "");
       map (fn  (name, value) => outLine (make_row [name, value] ""))
       (ListPair.zip (dirEntriesName, dirEntriesValue))
           handle ListPair.Zip => die "zip" ;
       outLine (horizontal_line 2 ""))
    end

  (* Adding initial entries. *)
  val _ = List.apply add_string_entry
        [("source_directory", source_directory),  (*e.g. "MLKitv2.0/KitDemo/"*)
	 ("target_directory", target_directory), 
	 ("log_directory", log_directory),  (*for .log files*)
	 ("path_to_runtime", path_to_runtime), 
	   (*e.g. "MLKitv2.0/bin/" ^ kit_version ^ "/runtime.o"*)
	 ("path_to_runtime_prof", path_to_runtime_prof),
	   (*e.g. "MLKitv2.0/bin/" ^ kit_version ^ "/runtime_prof.o"*)
	 ("c_compiler", c_compiler),  (*e.g. "cc -Aa" or "gcc -ansi"*)
	 ("c_libs", c_libs),  (*e.g. "-lm"*)
	 ("target_file_extension", target_file_extension),  (*e.g. ".c" or ".s"*)
	 ("path_to_kit_script", path_to_kit_script),
	   (*e.g. "MLKitv2.0/bin/" ^ kit_version ^ "/kit.script"*)
	 ("link_filename", link_filename),  (*e.g. "link"*)

	 (*the following are only used by TestEnv:*)
	 ("kit_version", kit_version), (*e.g. "ML_to_HPPA_on_HPUX"*)
	 ("kit_source_directory", kit_source_directory),
	 ("path_to_consult_file", path_to_consult_file),
	 ("test_env_directory", test_env_directory),  (*e.g. "MLKitv2.0/TestEnv/"*)
	 ("kit_architecture", kit_architecture)   (*e.g., "HPUX"*)]

  val _ = List.apply add_int_entry
        [("colwidth", colwidth)]

  val _ = List.apply add_bool_entry (* MEMO: Not all flags added...  (martin) *)
    [("type_check_lambda",type_check_lambda),
     ("unbox_datatypes", unbox_datatypes),
     ("tag_integers", tag_integers),
     ("tag_values", tag_values), 
     ("statistics_after_optimisation", statistics_after_optimisation),
     ("print_attop_atbot_expression", print_attop_atbot_expression),
     ("print_drop_regions_expression", print_drop_regions_expression),
     ("print_call_explicit_expression", print_call_explicit_expression),
     ("print_physical_size_inference_expression", print_physical_size_inference_expression),
     ("disable_atbot_analysis", disable_atbot_analysis),
     ("print_K_normal_forms", print_K_normal_forms),
     ("debug_which_at", debug_which_at),
     ("enhanced_atbot_analysis", enhanced_atbot_analysis),
     ("region_profiling", region_profiling),
     ("generate_lambda_code_with_program_points", gen_lambda_with_pp),
     ("generate_vcg_graph", gen_vcg_graph),
     ("warn_on_escaping_puts", warn_on_escaping_rhos),
     ("chat", chat),
     ("eliminate_polymorphic_equality", eliminate_polymorphic_equality),
     ("print_types", print_types),
     ("print_regions", print_regions),
     ("print_effects", print_effects), 
     ("all_multiplicities_infinite", all_multiplicities_infinite), 
     ("optimiser", optimiser),
     ("raggedRight", raggedRight),
     ("print_all_program_points", print_all_program_points),
     ("all_multiplicities_infinite", all_multiplicities_infinite), 
     ("log_to_file", log_to_file),  (*true => generate a .log file*)
     ("garbage_collection", garbage_collection),
     ("DEBUG_COMPILER", DEBUG_COMPILER)]

end (* Directory *)


                        (******************************************)
                        (*        structure Menu                  *)
                        (*                                        *)
                        (* Defines an abstract menu type and      *)
                        (* operations for building and interacting*)
                        (* with menus.                            *)
                        (******************************************)

structure Menu: sig
                    val add_flag: string * string * bool ref -> unit
                    val add_flag_to_menu: string list* string * string * bool ref -> unit
                    val add_string_to_menu: string list* string * string * string ref -> unit
                    val interact: unit -> unit
                  end =
struct

  datatype attribute = SWITCH of bool ref | VALUE of unit -> string

  datatype menu = 
    DISPLAY of item list
  | BUTTON of {r : bool ref, 
               text1: string, below1: menu, 
               text2: string, below2: menu}
  | ACTION of unit -> unit
  | NOMENU

  withtype item = {text: string, attr: attribute, below: menu} 
  
  
  fun empty NOMENU = true
    | empty _ = false;

  fun max(i:int, j: int) = if i>=j then i else j
  fun out(s) = output(std_out, s)
  fun outLine(s) = out(s ^ "\n")
  fun pad width text = String.padR "." width text;
  fun help () = outLine "\n\n***Try again\n"
  
  val menu = ref(DISPLAY[]) ; (* updated later*)
    
  fun mk_toggle (text, b: bool ref) = {text= text, attr = SWITCH b, below = NOMENU}


  fun mk_header text below : item = {text=text,attr=VALUE(fn _ => ""),below=below}


  (*read_string r () = read a string from std_in.  If the input is some
   string in quotes, read_string assigns it to the ref r (and sets the global
   (whooa!) ref u_or_q_from_read_string is to false), and returns.  If the
   input is u or q, read_string does not update r, sets
   u_or_q_from_read_string to false, and returns.  For other inputs
   read_string gives an error message and lets the user try again.*)

  val u_or_q_from_read_string = ref false
  fun read_string r () =
      (u_or_q_from_read_string := false ;
       outLine "<string in double quotes> or up (u): >" ;
       let val s = Instream.inputLine std_in
	   val (_, l) = List.splitFirst (fn ch => ch <> " ") (explode s)
	         handle List.First _ => ([],[])
       in
	 case l of 
	   [] => (help () ; read_string r ())
	 | "q" :: _  => u_or_q_from_read_string := true
	 | "u" :: _  => u_or_q_from_read_string := true
	 | "\"" (*"*) :: _  => 
           (case StringParse.parse (implode l) of 
	      OK (s,_) => r := s | _ => (help () ; read_string r ()))
	 | _ => (help () ; read_string r ())
       end)

  fun mk_string_action(r: string ref, text) =
          {text = text, attr = VALUE (fn () => "(" ^ String.string(!r) ^ ")"),
	   below = ACTION (read_string r)};


  fun add_flag (key: string, menu_txt: string, flag: bool ref) =
        (Directory.add_bool_entry(key,flag);
         case !menu of
           DISPLAY l =>
             (case rev l of
                ({text = "Extensions", attr,below = DISPLAY l2} :: rest)=>
                   menu:= DISPLAY(rev({text = "Extensions", attr=attr, 
                                       below = DISPLAY(l2 @[mk_toggle(menu_txt, flag)])}::rest))
              | rest' => 
                   menu:= DISPLAY(rev({text = "Extensions", attr=VALUE(fn () => ""), 
                                       below = DISPLAY([mk_toggle(menu_txt, flag)])}::rest'))
  
             )
          | _ => die "add_flag.menu not DISPLAY."
        );


  fun add_flag_to_menu(path : string list, key: string, menu_text: string, flag: bool ref): unit =
    let 
      fun add_flag (menu_text: string, flag: bool ref) menu =
         case menu of 
           DISPLAY l=> DISPLAY(l @ [mk_toggle(menu_text, flag)])
         | NOMENU => DISPLAY[mk_toggle(menu_text,flag)]
         | _ => die "add_flag_to_menu.menu not DISPLAY or NOMENU."

      fun add_flag_path(path : string list) menu : menu =
        case path 
	  of [] => add_flag (menu_text, flag) menu
	   | (txt::path') =>
	    let fun extend [] : item list = [mk_header txt (add_flag_path(path') NOMENU)] (* insert new header *)
		  | extend ((item as {text,attr,below})::items) =
	                if text=txt then {text=text,attr=attr,below=add_flag_path(path') below} :: items
			else item :: extend items 
	    in case menu 
		 of DISPLAY l => DISPLAY (extend l)
		  | BUTTON{r, text1, below1, text2, below2} =>
		   if text1=txt then
                     BUTTON{r=r, text1=text1, below1=add_flag_path(path') below1,text2=text2,below2=below2}
		   else if text2=txt then
                     BUTTON{r=r, text1=text1, below1=below1,text2=text2,below2=add_flag_path(path') below2}
		   else die "add_flag_to_menu.BUTTON."
		  | NOMENU => DISPLAY (extend [])
		  | _ => die "add_flag_to_menu.menu not DISPLAY, BUTTON or NOMENU." 
	    end
    in
      Directory.add_bool_entry(key,flag);
      menu:= add_flag_path(path)(!menu)
    end

  fun add_string_to_menu(path : string list, key: string, menu_text: string, str: string ref): unit =
    let 
      fun add_string(menu_text: string, str: string ref) menu =
         case menu of 
           DISPLAY l=> DISPLAY(l @ [mk_string_action(str,menu_text)])
         | NOMENU => DISPLAY[mk_string_action(str,menu_text)]
         | _ => die "add_string_to_menu.menu not DISPLAY or NOMENU."

      fun add_string_path(path : string list) menu : menu =
        case path 
	  of [] => add_string (menu_text, str) menu
	   | (txt::path') =>
	    let fun extend [] : item list = [mk_header txt (add_string_path(path') NOMENU)] (* insert new header *)
		  | extend ((item as {text,attr,below})::items) =
	                if text=txt then {text=text,attr=attr,below=add_string_path(path') below} :: items
			else item :: extend items 
	    in case menu 
		 of DISPLAY l => DISPLAY (extend l)
		  | BUTTON{r, text1, below1, text2, below2} =>
		   if text1=txt then
                     BUTTON{r=r, text1=text1, below1=add_string_path(path') below1,text2=text2,below2=below2}
		   else if text2=txt then
                     BUTTON{r=r, text1=text1, below1=below1,text2=text2,below2=add_string_path(path') below2}
		   else die "add_string_to_menu.BUTTON."
		  | NOMENU => DISPLAY (extend []) 
		  | _ => die "add_string_to_menu.menu not DISPLAY, BUTTON or NOMENU."
	    end
    in
      Directory.add_string_entry(key,str);
      menu:= add_string_path(path)(!menu)
    end

                    (******************)
                    (* Printing menus *)
                    (******************)
 
  fun display_lines(lines:  {text: string,
                             attr: attribute,
                             below: menu}list) : unit = 
    let 
           val width = List.foldL
                       (fn {text, ...} => fn acc:int => max(size text, acc))
                       0
                       (lines)
  
           fun outText (n,text, s: string) =
	         outLine("\t" ^ Int.string n ^ "\t" ^ pad width text ^ s)
           
           fun display_line (n, {text, attr, below}) =
             case (attr, below) of
               (SWITCH(ref true), NOMENU)     => outText(n, text, " on")
             | (SWITCH(ref true), _     )     => outText(n, text, " on >>>")
             | (SWITCH(ref false), NOMENU )   => outText(n, text, " off")
             | (SWITCH(ref false), _ )        => outText(n, text, " off (>>>)")
             | (VALUE show, NOMENU)           => outText(n, text, " " ^ show())
             | (VALUE show, _ )               => outText(n, text, " " ^ show() ^ " >>>")
  
           fun loop(n,[]) =()
           |   loop(n,line::rest) = (display_line(n, line); loop(n+1, rest))
                   
     in
       loop(0,lines);
       outLine "\nToggle line (t <number>), Activate line (a <number>), Up (u), or Quit(q): "
    end;
  
  fun blanks n =
    let 
      fun loop  n = if n<= 0 then [] else  " " :: loop(n-1)
    in
      implode(loop n)
    end;
  
                        (********************)
                        (* Printing buttons *)
                        (********************)

  fun show_button{r: bool ref, text1: string, below1: menu, 
                               text2: string, below2: menu} : unit=
    let 
  
        (* Bottons are printed as illustrated by the following example:
  
             - - - - - - - - - -   ====================
               Manual Settings     | Read from Script |
               off (>>>)           |      on >>>      |
             - - - - - - - - - -   ====================
     
         Toggle (t), Activate chosen (a), Up (u), or Quit (q)
       *)
  
        fun mk_odd n: int = if n mod 2 = 0 then n+1 else n
        fun hrepeat unit n = if n <=0 then [] else unit :: hrepeat unit (n-1);
        fun center text width = (* pad 'text' with blanks on the left and the right to 
                                achieve string with total width 'width' *)
            let val left_part = blanks ((width - size text) div 2) ^ text 
            in left_part ^ blanks(width - size left_part) 
            end
        fun show_choice (b: bool, text, below)  =
            let val botton_width = mk_odd (size text + 4) 
                val rule = implode(hrepeat (if b then "==" else "- ") (botton_width div 2)
                                   @ [(if b then "=" else "-")])
                val lrule = if b then "|" else " "
                fun centerline text = implode[lrule, " ",  center text (botton_width-4), " ", lrule]
                val status = if b then "on" ^
                         (if empty below then "" else " >>>")
                             else "off"^
                              (if empty below then "" else " (>>>)")
                val text_line = centerline text
                val status_line = centerline status
            in 
               (rule, text_line, status_line, rule)
            end
        val descend_is_possible = !r andalso not(empty below1) orelse
                                  not(!r) andalso not(empty below2)
        val bot1 as (l11,l12,l13,l14) = show_choice(!r, text1, below1)
        val bot2 as (l21,l22,l23,l24) = show_choice(not(!r), text2, below2)
  
    in
       outLine ("\t" ^ l11 ^ "  " ^ l21);
       outLine ("\t" ^ l12 ^ "  " ^ l22);
       outLine ("\t" ^ l13 ^ "  " ^ l23);
       outLine ("\t" ^ l14 ^ "  " ^ l24);
       outLine( "\n\nToggle (t)" ^ (if descend_is_possible then ", Activate chosen (a), Up (u), or Quit (q)"
                                else ", Up (u), or Quit (q)"))
    end;
       
  
  fun show_menu menu = case menu of
    DISPLAY l => display_lines l
  | BUTTON bot => show_button bot
  | _ => ();
  
  
               (************************************************)
               (* Printing an overview of the entire menu tree *)
               (************************************************)

  (* this code uses leading newlines whereas normal
     printing of menus uses trailing newlines in output *)
  
  val delta = 4
  fun outLineInd indent s =
     (outLine ""; (*start new line*)
      out(blanks indent ^ s)
     )
  fun show_full_menu  indent menu = case menu of
    DISPLAY l => List.apply (show_full_item indent) l  
  | BUTTON{r, text1, below1, text2, below2}=>
      (outLineInd (indent) ("BUTTON ON: " ^ text1);
      show_full_menu (indent+delta) below1;
      outLineInd (indent) ("BUTTON OFF: " ^ text2);
      show_full_menu (indent+delta) below2)
  | ACTION _ => out " fn"
  | NOMENU => ()
  and show_full_item indent {text: string, attr = VALUE show, below} =
        (outLineInd indent (text ^ " " ^ show());
         show_full_menu(indent+delta)below)
    | show_full_item indent {text, attr = SWITCH _, below} =
        (outLineInd indent (text ^ "(switch)");
         show_full_menu(indent+delta)below);
  
  val show_full_menu_r = ref(fn () => 
       (outLine "\n----------------------------------------------------\n";
        show_full_menu 5 (!menu); 
        outLine "\n----------------------------------------------------\n"))
  
                 (*************************************************)
                 (* Menu commands (entered by user interactively) *)
                 (*************************************************)
  
  datatype cmd =   TOGGLE of int 
                 | TOGGLE_BOT 
                 | ACTIVATE_BOT 
                 | ACTIVATE of int 
                 | ACTIVATE_OR_TOGGLE of int
                 | UP 
                 | QUIT 
                 | HELP;
  
  fun read_display_cmd(): cmd =
    (output(std_out, "\n>");
     let val s = Instream.inputLine std_in
         val (_, l) = List.splitFirst (fn ch => ch <> " ") (explode s)
	       handle List.First _ => ([],[])
     in case l of
          [] => HELP
        | "q" :: _ => QUIT
        | "u" :: _ => UP
        | "a" :: l' => (case IntParse.parse (implode l') of
                         OK(i, _) => ACTIVATE i
                       | _ => HELP)
        | "t" :: l' => (case IntParse.parse (implode l') of
                         OK(i, _) => TOGGLE i
                       | _ => HELP)
        | ch :: l' =>  (case IntParse.parse (implode l) of
                         OK(n,_) => ACTIVATE_OR_TOGGLE n
                        | _ => HELP)
     end);
  
  fun read_button_cmd () : cmd =
        (output (std_out, "\n>");
	 let val s = Instream.inputLine std_in
	     val (_, l) = List.splitFirst (fn ch => ch <> " ") (explode s)
	           handle List.First _ => ([],[])
	 in case l of
	   [] => HELP
	 | "q" :: _ => QUIT
	 | "u" :: _ => UP
	 | "a" :: l' => ACTIVATE_BOT
	 | "t" :: l' => TOGGLE_BOT
	 | _ => HELP
	 end);
  
  
                         (**********************************************)
                         (* Auxiliary functions for constructing menus *)
                         (**********************************************)

  val noop_attr : attribute = VALUE (fn () => "")
  fun mk_header text below  : item= 
              {text = text, attr = VALUE(fn _ => ""), below = below};
  fun mk_toggled_header text r below = 
              {text = text, attr = SWITCH r, below = below};
  fun mk_button(r, text1, below1, text2, below2) =
               BUTTON{r = r, text1 = text1, below1 = below1, text2 = text2, below2 = below2}
  fun mk_simple_button(r, text1, text2) = 
               mk_button(r, text1,  NOMENU, text2  , NOMENU);
  fun mk_action (text, f: unit -> unit) = 
               {text = text, attr = VALUE(fn _ => ""), below = ACTION f}

  fun mk_int_action(r: int ref, text) =
              let fun read_int() =
                   (outLine "<number> or up (u): >";
                    let val s = Instream.inputLine std_in
                        val (_, l) = List.splitFirst(fn ch => ch <> " ")(explode s)
			      handle List.First _ => ([],[])
                    in case l of 
                          [] => (help(); read_int())
                        | "q" :: _  => ()
                        | "u" :: _  => ()
                        | _ => case IntParse.parse (implode l) of
                                    OK(i,_) => r:= i | _ => (help(); read_int())
                    end)
              in
               {text = text, attr = VALUE(fn _ => Int.string(!r)),
                below = ACTION read_int}
              end;
  
  fun read_int_list r () =
    (outLine "<type an int list, e.g. [4,3]> or up (u): >";
     let
       val s = Instream.inputLine std_in
       (*val _ = output(std_out, s)*)
       val parseInt = IntParse.parse
       val parseIntList = ListParse.parseSep "[" "]" "," parseInt
     in
       case explode s
	 of [] => (help(); read_int_list r ())
	  | "u" :: _  => ()
	  | "q" :: _  => ()
	  | "["::_ => (case parseIntList s
			      handle ListParse.Sep _ => die "parseIntList" of
			 OK(l',_) => (r := l')
		       | _ => (help(); read_int_list r ()))
	  | _ => (help(); read_int_list r ())
     end)

  fun read_int_pair_list r () =
    (outLine "<type an int pair list of region variables,\n\
	  \e.g. [(formal reg. var. at pp.,letregion bound reg. var.)]> or up (u): >" ;
     let
       val s = Instream.inputLine std_in
       (*val _ = output(std_out, s)*)
       val parseInt = IntParse.parse
       val parseIntPair = PairParse.parse parseInt parseInt
       val parseIntPairList = ListParse.parseSep "[" "]" "," parseIntPair
     in
       case (explode s)
	 of [] => (help(); read_int_pair_list r ())
	  | "u" :: _  => ()
	  | "q" :: _  => ()
	  | "["::_ => (case parseIntPairList s
			      handle ListParse.Sep _ => die "parseIntList" of
			 OK(l',_) => (r := l')
		       | _ => (help(); read_int_pair_list r ()))
	  | _ => (help(); read_int_pair_list r ())
     end)

    fun mk_int_list_action(r: int list ref, text) =
              {text = text, 
	       attr = VALUE 
	       (fn _ => (List.string 
			 (fn i => (Int.string i))
			 (!r))),
	       below = ACTION (read_int_list r)};

    fun mk_int_pair_list_action(r: (int*int) list ref, text) =
              {text = text, 
	       attr = VALUE 
	       (fn _ => (List.string 
			 (fn (i1, i2) => 
			  "(" ^ Int.string i1 ^ "," ^ Int.string i2 ^ ")")
			 (!r))),
	       below = ACTION (read_int_pair_list r)};
  
                     (*********************************)
                     (*  Construction of the Kit Menu *)
                     (*********************************)


  (*0. Project*)

    val project_item : item =
          mk_header "Project"
	  (DISPLAY
	   [mk_string_action (project_file_name, "Set project file name"),
	    {text = "(Re)read project file", attr = noop_attr, 
	     below = ACTION (fn () => !read_project_ref (!project_file_name))},
	    {text = "Show project status", attr = noop_attr, 
	     below = ACTION (fn () => !show_project_ref())},
	    {text = "Compile and link project", attr = noop_attr, 
	     below = ACTION (fn () => !build_project_ref())}])

  (*1. Printing of intermediate forms*)

    val printing_of_intermediate_forms_item : item =
          mk_header "Printing of intermediate forms"
	  (DISPLAY
	   [mk_toggle ("statistics after optimisation", statistics_after_optimisation),
	    mk_toggle ("print atbot expression", print_attop_atbot_expression),
	    mk_toggle ("print drop regions expression", print_drop_regions_expression),
	    mk_toggle ("print call-explicit expression", print_call_explicit_expression),
	    mk_toggle ("print physical size inference expression",
		       print_physical_size_inference_expression)])
    

  (*2. Layout*)

    val layout_item : item = mk_header "Layout"
          (DISPLAY
	   [mk_toggle ("print types ", print_types),
	    mk_toggle ("print effects", print_effects),
	    mk_toggle ("print regions ", print_regions),
	    mk_toggle ("print in K-Normal Form", print_K_normal_forms),
	    mk_toggle ("ragged right margin in pretty-printing", raggedRight),
	    mk_int_action (colwidth, "text width")])


  (*3. Control*)

  local
    val multiplicity_inference_items : item list =
          [mk_toggle ("all multiplicities infinite (for POPL 96)", all_multiplicities_infinite)]
    val storage_mode_analysis_items : item list =
          [mk_toggle ("all storage modes attop  (for POPL 96)", disable_atbot_analysis)]
  in
    val control_item : item = mk_header "Control"
          (DISPLAY
	   ([mk_toggle ("chat", chat),
	    {text = "Optimiser", attr = noop_attr,
	     below = DISPLAY
	     [mk_toggle ("optimiser ", optimiser)]},
	    {text = "print entire menu", attr = noop_attr,
	     below = ACTION (!show_full_menu_r)},
	    {text = "print all flags and variables", attr = noop_attr,
	     below = ACTION Directory.show_script_entries}]
	   @ multiplicity_inference_items
	   @ storage_mode_analysis_items
	   @ [mk_string_action (c_libs, "link with library")]))
  end (*local*)


  (*3,5. File menu*)

  val file_item : item = mk_header "File"
        (DISPLAY
	 [mk_string_action (source_directory, "Source directory"),
	  mk_string_action (target_directory, "Target directory"),
	  mk_toggle ("Log to file", log_to_file),
	  mk_string_action (log_directory, "Log directory"),
	  mk_string_action (path_to_kit_script, "Set script file name"),
	  {text = "Read the script", attr = VALUE (fn _ => ""), 
	   below = ACTION Directory.readScript}])



  (*4. Profiling menu*)

  local 
    val program_points_item =
          {text = "Program points", attr = VALUE(fn _ => ""),
	   below = mk_button (print_all_program_points, "Print all program points", NOMENU,
			      "Print some program points", 
			      DISPLAY [mk_int_list_action
				       (program_points, "Program points to print")])}
    fun show_flag true = "on" 
      | show_flag false = "off"
    fun toggle_ref r = r := not (! r)
  in
    val profiling_item : item = mk_header "Profiling" 
          (DISPLAY
	   [{text = "region profiling",
	     attr = VALUE (fn () => show_flag (!region_profiling)),
	     below = ACTION (fn () => toggle_ref region_profiling)},
	    mk_toggle ("generate lambda program with program points", gen_lambda_with_pp),
	    mk_toggle ("generate region flow graph (.vcg file)", gen_vcg_graph),
	    mk_int_pair_list_action(region_paths, "paths between two nodes in region flow graph")
(*TODO 31/03/1997 20:37. tho.:
            , program_points_item
*)
	    ])
  end


  (*5. Test environment*)

  val test_environment_item : item = mk_header "Test environment" (DISPLAY
        [{text = "run test", attr = noop_attr,
	  below = ACTION (fn () => (print "\n\n\n\n\n" ; (!test_ref) ()))}])


  (*6. Debug Kit*)
  
  local
    local
      val debug_elabdec : menu = DISPLAY 
	    [mk_toggle ("debug types ", DEBUG_TYPES),
	     mk_toggle ("debug type variables ", DEBUG_TYVARS),
	     mk_toggle ("debug elaboration of flexible records ", DEBUG_FLEXRECORDS),
	     mk_toggle ("debug static objects ", DEBUG_STATOBJECTS)]
    in
      val front_end_item : item  =
	    {text = "Front End", attr = VALUE(fn _ => ""),
	     below = DISPLAY 
	       [mk_toggle ("debug lexing ", DEBUG_LEXING),
		mk_toggle ("debug parsing ", DEBUG_PARSING),
		{text = "debug elabdec", attr = SWITCH DEBUG_ELABDEC,
		 below = debug_elabdec},
		mk_toggle ("debug elabtopdec ", DEBUG_ELABTOPDEC),
		mk_toggle ("debug environments ", DEBUG_ENVIRONMENTS),
		mk_toggle ("debug error printing ", DEBUG_ERRORPRINT),
		mk_toggle ("debug evaluation of Core declarations ", DEBUG_EVALDEC),
		mk_toggle ("debug evaluation of Modules declarations ", DEBUG_EVALTOPDEC)]}
    end (*local*)
    val lambda_item =
        {text = "Lambda", attr = VALUE(fn _ => ""),
	 below =
	 DISPLAY
	 [mk_toggle ("debug decision trees ", DEBUG_DECISIONTREE),
	  mk_toggle ("debug match compiler ", DEBUG_MATCHCOMPILER)]}

    val backend_item : item = mk_header "Backend" NOMENU
  in
    val debug_kit_item : item = mk_header "Debug Kit"
          (DISPLAY 
	    [front_end_item,
	     lambda_item,
	     mk_toggle ("debug compiler ", DEBUG_COMPILER),
	     mk_toggle ("debug optimiser ", DEBUG_OPTIMISER),
	     mk_toggle ("debug which_at (storage mode analysis)", debug_which_at),
	     backend_item])
  end (*local*)


  (*7. Compile an sml file*)
  (*8. Compile it again*)

  local fun comp_current_source_file () = !comp_ref (!current_source_file)
  in
    val compile_an_sml_file_item : item =
          {text = "Compile an sml file", attr = noop_attr, 
	   below = ACTION (fn () => (read_string current_source_file () ;
				     if !u_or_q_from_read_string then () else
				     comp_current_source_file ()))}
    val compile_it_again_item : item =
          {text = "Compile it again",
	   attr = VALUE (fn () => "(" ^ String.string (!current_source_file) ^ ")"),
	   below = ACTION comp_current_source_file}
  end (*local*)

  (* 9. Garbage Collection *)
  val gc_item = mk_toggle("Garbage Collection", garbage_collection)

  (* ---------------------------------------------------------------------- *)
  (*    Initializing menu.                                                  *)
  (* ---------------------------------------------------------------------- *)

  val _ =  menu := (DISPLAY [(*0.*) project_item,
			     (*1.*) printing_of_intermediate_forms_item,
			     (*2.*) layout_item,
			     (*3.*) control_item,
			     (*3,5.*) file_item,
			     (*4.*) profiling_item,
			     (*5.*) test_environment_item,
			     (*6.*) debug_kit_item,
                             (*7.*) compile_an_sml_file_item,
			     (*8.*) compile_it_again_item,
                             (*9.*) gc_item]) ;

                         (**************************)
                         (* interact               *)
                         (**************************)

  exception Quit; 

  fun interact () = interact0 ()
        handle Quit => ()
	     | Crash.CRASH => (outLine "*** CRASH raised *" ; interact ()) 
	     | Io s => (outLine ("*** Io \"" ^ s ^ "\" raised *"); interact ())
	     | SML_NJ.Unsafe.CInterface.SystemCall s =>
	         (outLine ("*** SystemCall \"" ^ s ^ "\" raised *"); interact ())
	     | Overflow => (outLine "*** Overflow raised *"; interact ())
	     | e => (outLine "*** Uncaught exception\nI shall reraise it...\n" ;
		     raise e ;
		     interact ())

  and interact0 () = inter ([], !menu)
  
                        (*************************************************)
                        (* inter(path,menu):                             *)
                        (*                                               *)
                        (*    the read-eval loop of the interaction      *)
                        (*    'path' is the path from the root to 'menu' *)
                        (*    and is used for printing                   *)
                        (*************************************************)

  and inter (path, menu : menu) : unit = 
    (case menu of
       DISPLAY l => 
        (show_path path;
         outLine "";
         show_menu menu; 
         case read_display_cmd () : cmd of
           ACTIVATE n =>
	     ((case List.nth n l of
		{below = NOMENU, ...} => 
		  (outLine("***Nothing to activate ");
		   inter(path,menu))
	      | {below, attr = SWITCH(ref false), ...} =>
		  (outLine ("***Switch is disabled - use  `t" ^ Int.string n
			    ^ "' to toggle menu, if that is what you want");
		  inter(path, menu) )
	      | {text, below, ...} => (inter(text::path, below); inter(path, menu))
		  ) handle List.Subscript _ => (outLine"***Number out of range" ; inter(path, menu)))
          | TOGGLE n =>
	      ((case List.nth n l of
		  {attr = SWITCH r, ...} => 
		    (r:= not(!r); inter(path, menu))
		| {attr = VALUE _ , ...} => 
		    (outLine("***Nothing to toggle ");
		     inter(path, menu) )
                    ) handle List.Subscript _ =>
		               (outLine "***Number out of range" ;
				help(); inter(path, menu)))
          | ACTIVATE_OR_TOGGLE n =>
	      ((case List.nth n l of 
		  {attr = SWITCH(r as ref false), ...} =>
		    (* assume toggle *) 
		    (r := not (!r) ; inter (path, menu))
		| {attr = SWITCH(r as ref true), below = NOMENU, ...} =>
		    (* assume toggle *) 
		    (r := not (!r) ; inter (path, menu))
		| {attr = VALUE _ , below, text,...} => 
		    (* assume activate *)
		    (inter (text::path, below) ; inter(path, menu))
		| _ => (help () ; inter (path, menu))
		    ) handle List.Subscript _ =>
		               (outLine "***Number out of range" ;
				help() ; inter (path, menu)))
          | UP => (case path of (*ignore u when at top-level menu*)
		     [] => inter (path,menu)
		   | _ => ())
          | QUIT => raise Quit
          | _ => (help () ; inter (path,menu)))
     | BUTTON (bot as {r: bool ref, text1: string, below1: menu,
		                    text2: string, below2: menu}) => 
        (show_path path;
         outLine "";
         show_menu menu; 
         case read_button_cmd () : cmd of
           TOGGLE_BOT => 
             (r := not (!r);
              inter(path, menu))
         | ACTIVATE_BOT => 
             if !r then
	       if not (empty below1) then inter (text1::path,below1)
	       else outLine "***Nothing to activate"
	     else 
	       if not (empty below2) then inter (text2::path,below2)
	       else outLine "***Nothing to activate"
         | UP => ()
         | QUIT => raise Quit
         | _ => (help(); inter(path,menu)))
     | ACTION f => f ()
     | NOMENU => ())

  and show_path (l : string list) = 
        outLine(List.stringSep "\t" "" "/" (fn s => s) (rev l));

end (*structure Menu*)

exception ParseScript = ParseScript.ParseScript
type state = Directory.state
val get_state = Directory.get_state
val reset_state = Directory.reset_state
val is_on = Directory.is_on
val turn_on = Directory.turn_on
val turn_off = Directory.turn_off
val lookup_flag_entry = Directory.lookup_flag_entry
val add_string_entry = Directory.add_string_entry
val get_string_entry = Directory.get_string_entry
val lookup_string_entry = Directory.lookup_string_entry
val read_script = Directory.readScript
fun read_script_name name = Directory.readScriptName name
val show_script_entries = Directory.show_script_entries
val add_flag = Menu.add_flag   
val add_flag_to_menu = Menu.add_flag_to_menu
val add_string_to_menu = Menu.add_string_to_menu
val interact = Menu.interact

end; (* functor Flags *)  
   
  
