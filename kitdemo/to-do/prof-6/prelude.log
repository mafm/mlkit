

********** /vol/topps/disk02/MLKIT-afterVersion1/hojfeld/sommerskole/version2/kitdemo/prelude.sml *************



Report: LAMBDA CODE WITH PROGRAM POINTS:: 
   let exception Ord : (exn,r1) (* exn value or name attop r1 pp2 *); 
       exception Chr : (exn,r1) (* exn value or name attop r1 pp3 *); 
       exception Div : (exn,r1) (* exn value or name attop r1 pp4 *); 
       exception Mod : (exn,r1) (* exn value or name attop r1 pp5 *); 
       exception Quot : (exn,r1) (* exn value or name attop r1 pp6 *); 
       exception Floor : (exn,r1) (* exn value or name attop r1 pp7 *); 
       exception Sqrt : (exn,r1) (* exn value or name attop r1 pp8 *); 
       exception Exp : (exn,r1) (* exn value or name attop r1 pp9 *); 
       exception Ln : (exn,r1) (* exn value or name attop r1 pp10 *); 
       exception 
           Io 
           : 
           (((string,r4)->(exn,r1)),r1) 
           (* exn value or name attop r1 pp11 *); 
       fun = attop r1 pp12 [r47:3, r40:2] (v2123)= 
            fn attop r47 pp14 var97 => 
            let val x = #0 var97; val y = #1 var97 in v2123 (x, y) attop r40 pp13 end ; 
       fun := attop r1 pp16 [r58:0] (var98)= 
           let val x = #0 var98; val y = #1 var98 in (x := y) end ; 
       fun ! attop r1 pp18 [] (x)= !x; 
       fun ord attop r1 pp20 [] (c)= ccall(ordString, c, Ord); 
       fun chr attop r1 pp23 [r80:inf] (i)= 
           ccall(chrStringProfiling,  sat r80 pp24, i, Chr); 
       fun size attop r1 pp26 [] (s)= ccall(sizeString, s); 
       fun explode attop r1 pp29 [r98:inf, r97:inf, r96:inf] (str)= 
           ccall(explodeStringProfiling, 
                  sat r98 pp30, 
                  sat r97 pp30, 
                  attop r96 pp30, 
                 str
           ); 
       fun implode attop r1 pp32 [r110:inf] (strs)= 
           ccall(implodeStringProfiling,  attop r110 pp33, strs); 
       fun ^ attop r1 pp35 [r122:inf] (var105)= 
           let val s1 = #0 var105; val s2 = #1 var105
           in  ccall(concatStringProfiling,  attop r122 pp36, s1, s2)
           end ; 
       fun div attop r1 pp38 [] (var106)= 
           let val x = #0 var106; val y = #1 var106 in ccall(divInt, x, y, Div) end ; 
       fun mod attop r1 pp41 [] (var107)= 
           let val x = #0 var107; val y = #1 var107 in ccall(modInt, x, y, Mod) end ; 
       fun real attop r1 pp44 [r140:2] (x)= ccall(realInt,  sat r140 pp45, x); 
       fun floor attop r1 pp47 [] (x)= ccall(floorFloat, x, Floor); 
       fun / attop r1 pp50 [r158:2] (var110)= 
           let val x = #0 var110; val y = #1 var110
           in  ccall(divFloat,  attop r158 pp51, x, y, Quot)
           end ; 
       fun sqrt attop r1 pp53 [r166:2] (x)= ccall(sqrtFloat,  attop r166 pp54, x, Sqrt); 
       fun exp attop r1 pp56 [r174:2] (x)= ccall(expFloat,  attop r174 pp57, x, Exp); 
       fun ln attop r1 pp59 [r182:2] (x)= ccall(lnFloat,  attop r182 pp60, x, Ln); 
       fun sin attop r1 pp62 [r190:2] (x)= ccall(sinFloat,  attop r190 pp63, x); 
       fun cos attop r1 pp65 [r198:2] (x)= ccall(cosFloat,  attop r198 pp66, x); 
       fun arctan attop r1 pp68 [r206:2] (x)= ccall(arctanFloat,  attop r206 pp69, x); 
       val std_in = 
           let val v2114 = ccall(stdInStream, 0) in INS attop r1 pp72 v2114 end ; 
       val std_out = 
           let val v2113 = ccall(stdOutStream, 0) in OUTS attop r1 pp74 v2113 end ; 
       exception CANNOT_OPEN : (exn,r1) (* exn value or name attop r1 pp75 *); 
       fun open_in attop r1 pp76 [r222:2] (f)= 
           letregion r230:6 
           in  let val v1989 = ccall(openInStream, f, CANNOT_OPEN)
               in  INS attop r222 pp78 v1989
               end  handle 
               (fn atbot r230 pp82 CANNOT_OPEN => 
                (case CANNOT_OPEN 
                   of CANNOT_OPEN => 
                      raise let val v1991 = 
                                    letregion r227:0 
                                    in ccall(concatStringProfiling,  attop r4 pp80, "Cannot open "attop r227 pp79, f) 
                                    end (*r227:0*)
                            in  Io attop r1 pp81 v1991
                            end 
                   |  _ => raise CANNOT_OPEN
                ) (*case*) 
               ) 
           end (*r230:6*); 
       fun open_out attop r1 pp84 [r239:2] (f)= 
           letregion r247:6 
           in  let val v1995 = ccall(openOutStream, f, CANNOT_OPEN)
               in  OUTS attop r239 pp86 v1995
               end  handle 
               (fn atbot r247 pp90 CANNOT_OPEN => 
                (case CANNOT_OPEN 
                   of CANNOT_OPEN => 
                      raise let val v1997 = 
                                    letregion r244:0 
                                    in ccall(concatStringProfiling,  attop r4 pp88, "Cannot open "attop r244 pp87, f) 
                                    end (*r244:0*)
                            in  Io attop r1 pp89 v1997
                            end 
                   |  _ => raise CANNOT_OPEN
                ) (*case*) 
               ) 
           end (*r247:6*); 
       fun input attop r1 pp92 [r260:inf] (var119)= 
           let val v2002 = #0 var119; val v2004 = decon_INS v2002; val n = #1 var119
           in  ccall(inputStreamProfiling,  sat r260 pp93, v2004, n)
           end ; 
       fun lookahead attop r1 pp95 [r271:inf] (var120)= 
           let val v2008 = decon_INS var120
           in  ccall(lookaheadStreamProfiling,  sat r271 pp96, v2008)
           end ; 
       fun close_in attop r1 pp98 [] (var121)= 
           let val v2012 = decon_INS var121 in ccall(closeStream, v2012) end ; 
       fun end_of_stream attop r1 pp101 [] (var122)= 
           let val v2016 = decon_INS var122 in ccall(endOfStream, v2016) end ; 
       val output_exval = Io attop r1 pp105 "Output stream is closed"attop r4 pp104; 
       fun output attop r1 pp106 [] (var123)= 
           let val v2022 = #0 var123; val v2024 = decon_OUTS v2022; val str = #1 var123
           in  ccall(outputStream, v2024, str, output_exval)
           end ; 
       fun close_out attop r1 pp109 [] (var124)= 
           let val v2028 = decon_OUTS var124 in ccall(closeStream, v2028) end ; 
       fun flush_out attop r1 pp112 [] (var125)= 
           let val v2032 = decon_OUTS var125 in ccall(flushStream, v2032) end ; 
       fun not attop r1 pp115 [] (v2111)= 
           (case v2111 of true => false | false => true) (*case*) ; 
       fun o attop r1 pp117 [r354:2] (var126)= 
           fn attop r354 pp118 x => let val f = #0 var126; val g = #1 var126 in f g x end ; 
       fun <> attop r1 pp120 [r379:3, r372:2] (v2124)= 
            fn attop r379 pp122 var128 => 
            let val a = #0 var128; val b = #1 var128
            in  (case v2124 (a, b) attop r372 pp121 of true => false | false => true) (*case*) 
            end ; 
       fun @ attop r1 pp124 [r396:inf, r395:inf] (var129)= 
           (case #0 var129 
              of nil => #1 var129
              |  :: => 
                 let val v2051 = #0 var129; 
                     val v2053 = decon_:: v2051; 
                     val M = #1 var129; 
                     val x = #0 v2053; 
                     val L = #1 v2053; 
                     val v2058 = 
                         (x, 
                          letregion r411:2, r416:2 
                          in @[attop r396 pp127,attop r395 pp128] atbot r416 pp126 (L, M) atbot r411 pp125 
                          end (*r411:2, r416:2*)
                         ) attop r395 pp129
                 in  :: attop r396 pp130 v2058
                 end 
           ) (*case*) ; 
       fun map attop r1 pp132 [r473:5, r458:2, r457:2] (var130)= 
            fn attop r473 pp140 var131 => 
            (case var131 
               of nil => nil attop r458 pp133
               |  :: => 
                  let val v2066 = decon_:: var131; 
                      val x = #0 v2066; 
                      val L = #1 v2066; 
                      val v2071 = 
                          (var130 x, 
                           letregion r459:5 
                           in  letregion r463:3 
                               in map[atbot r459 pp135,attop r458 pp136,attop r457 pp137] atbot r463 pp134 var130 
                               end (*r463:3*) 
                               L 
                           end (*r459:5*)
                          ) attop r457 pp138
                  in  :: attop r458 pp139 v2071
                  end 
            ) (*case*) ; 
       fun rev attop r1 pp142 [r542:inf, r541:inf] (l)= 
           letregion r487:1 
           in let fun rev_rec atbot r487 pp143 [r509:inf, r505:inf, r504:inf] (var132)= 
                      (case #0 var132 
                         of nil => var132
                         |  :: => 
                            let val v2079 = #0 var132; 
                                val v2081 = decon_:: v2079; 
                                val acc = #1 var132; 
                                val x = #0 v2081; 
                                val xs = #1 v2081
                            in  letregion r529:3 
                                in rev_rec[sat r509 pp148,sat r505 pp149,sat r504 pp150] atbot r529 pp147 
                                   (xs, 
                                    let val v2086 = (x, acc) attop r504 pp144 in :: attop r505 pp145 v2086 end 
                                   ) sat r509 pp146 
                                end (*r529:3*)
                            end 
                      ) (*case*) 
              in  letregion r543:inf 
                  in let val v2087 = 
                             letregion r545:3 
                             in rev_rec[atbot r543 pp155,sat r542 pp156,sat r541 pp157] atbot r545 pp154 
                                (l, nil attop r542 pp152) atbot r543 pp153 
                             end (*r545:3*)
                     in  #1 v2087
                     end  
                  end (*r543:inf*)
              end  
           end (*r487:1*); 
       fun length attop r1 pp159 [] (var134)= 
           (case var134 
              of nil => 0
              |  :: => let val v2092 = decon_:: var134; val xs = #1 v2092 in 1 + length[] xs end 
           ) (*case*) ; 
       fun app attop r1 pp162 [r606:3] (var135)= 
            fn attop r606 pp165 var136 => 
            (case var136 
               of nil => ()
               |  :: => 
                  let val v2102 = decon_:: var136; 
                      val x = #0 v2102; 
                      val xs = #1 v2102; 
                      val _not_used = let val v2107 = var135 x in () end 
                  in  letregion r600:3 
                      in  letregion r604:1 in app[atbot r600 pp164] atbot r604 pp163 var135 end (*r604:1*) 
                          xs 
                      end (*r600:3*)
                  end 
            ) (*case*) ; 
       fun say attop r1 pp167 [] (s)= 
           letregion r615:2, r617:0 
           in output[] (std_out, s) atbot r615 pp168 
           end (*r615:2, r617:0*)
   in  {|
       =: (_,r1), 
       :=: (_,r1), 
       !: (_,r1), 
       ord: (_,r1), 
       chr: (_,r1), 
       size: (_,r1), 
       explode: (_,r1), 
       implode: (_,r1), 
       ^: (_,r1), 
       div: (_,r1), 
       mod: (_,r1), 
       real: (_,r1), 
       floor: (_,r1), 
       /: (_,r1), 
       sqrt: (_,r1), 
       exp: (_,r1), 
       ln: (_,r1), 
       sin: (_,r1), 
       cos: (_,r1), 
       arctan: (_,r1), 
       std_in: (_,r1), 
       std_out: (_,r1), 
       open_in: (_,r1), 
       open_out: (_,r1), 
       input: (_,r1), 
       lookahead: (_,r1), 
       close_in: (_,r1), 
       end_of_stream: (_,r1), 
       output_exval: (_,r1), 
       output: (_,r1), 
       close_out: (_,r1), 
       flush_out: (_,r1), 
       not: (_,r1), 
       o: (_,r1), 
       <>: (_,r1), 
       @: (_,r1), 
       map: (_,r1), 
       rev: (_,r1), 
       length: (_,r1), 
       app: (_,r1), 
       say: (_,r1), 
       Ord, 
       Chr, 
       Div, 
       Mod, 
       Quot, 
       Floor, 
       Sqrt, 
       Exp, 
       Ln, 
       Io, 
       CANNOT_OPEN
       |}
   end 


Report: REGION FLOW GRAPH FOR PROFILING:: 
   Begin layout of region flow graph and SCC-graph.
       [Starting layout of graph...
       LETREGION[r227:0]
       LETREGION[r230:6]
       LETREGION[r244:0]
       LETREGION[r247:6]
       @[r395:inf]   --r395 attop-->   [*r395*] ;
       @[r396:inf]   --r396 attop-->   [*r396*] ;
       LETREGION[r411:2]
       LETREGION[r416:2]
       map[r457:2]   --r457 attop-->   [*r457*] ;
       map[r458:2]   --r458 attop-->   [*r458*] ;
       LETREGION[r459:5]
       LETREGION[r463:3]
       map[r473:5]   --r473 atbot-->   [*r459*] ;
       LETREGION[r487:1]
       rev_rec[r504:inf]
          --r504 sat-->   [*r504*] ;
          --r504 sat-->   unknown[r541:unknown];
       rev_rec[r505:inf]
          --r505 sat-->   [*r505*] ;
          --r505 sat-->   unknown[r542:unknown];
       rev_rec[r509:inf]
          --r509 sat-->   [*r509*] ;
          --r509 atbot-->   LETREGION[r543:inf];
       LETREGION[r545:3]
       LETREGION[r600:3]
       LETREGION[r604:1]
       app[r606:3]   --r606 atbot-->   [*r600*] ;
       LETREGION[r615:2]
       LETREGION[r617:0]
       ...Finishing layout of graph]
       [Starting layout of graph...
       [sccNo 26: r617,]
       [sccNo 25: r615,]
       [sccNo 24: r606,]   --sccNo 24-->   [sccNo 22: r600,];
       [sccNo 23: r604,]
       [sccNo 21: r545,]
       [sccNo 20: r509,]   --sccNo 20-->   [sccNo 19: r543,];
       [sccNo 18: r505,]   --sccNo 18-->   [sccNo 17: r542,];
       [sccNo 16: r504,]   --sccNo 16-->   [sccNo 15: r541,];
       [sccNo 14: r487,]
       [sccNo 13: r473,]   --sccNo 13-->   [sccNo 11: r459,];
       [sccNo 12: r463,]
       [sccNo 10: r458,]
       [sccNo 9: r457,]
       [sccNo 8: r416,]
       [sccNo 7: r411,]
       [sccNo 6: r396,]
       [sccNo 5: r395,]
       [sccNo 4: r247,]
       [sccNo 3: r244,]
       [sccNo 2: r230,]
       [sccNo 1: r227,]
       ...Finishing layout of graph]
   End layout of region flow graph and SCC-graph.


 *** Warnings ***
open_in	 has a type scheme with escaping put effects on region(s): 
r4, which is also free in the type (schemes) of :  Io
r1, which is also free in the type (schemes) of :  plus_int plus_float = := ! ord chr size explode implode ^ div mod real floor / sqrt exp ln sin cos arctan std_in std_out Match Bind Ord Chr Div Mod Quot Floor Sqrt Exp Ln Io CANNOT_OPEN

open_out	 has a type scheme with escaping put effects on region(s): 
r4 (see above)
r1 (see above)



